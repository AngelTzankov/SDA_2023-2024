#include <iostream>
#include <stack>
#include <vector>

using namespace std;

/*
В тази задача, за всеки елемент от масива искаме да намерим каква е площта на правоъгълника, в 
който този елемент е минимален. Например за масива 3 2 4 3, за първият елемент отговорът е 3, 
тъй като няма друг правоъгълник, освен този, който съдържа само първата 3-ка, в който 3 да е 
минимален. За втория елемент, това е целия масив и площта е 8, за 4-ката отговортъ е 4 и за 
последната 3-ка отговорът е 6. Сравнително лесно наблюдение е, че отговорът на задачата е 
най-големият елемент в този масив. 

За да съставим този масив трябва да направим 2 прекалкулации:
 - Да намерим за всеки елемент първият индекс отляво на него, в който се съдържа по-малко число
     - За горния пример масив тези елементи ще са l[i] -> -1 -1 2 2
 - Да намерим за всеки елемент първият индекс отдясно на него, в който се съдържа по-малко число
     - За горния пример масив тези елементи ще са r[i] -> 0 4 2 4
Бележка: ако няма такъв индекс в l[i] записваме -1. Ако няма такъв в r[i] - записваме n

Ако имаме тези два масива то стойността на всеки от горните правоъгълници е arr[i] * (r[i] - l[i] + 1)

Отговорът на задачата е Max(arr[i] * (r[i] - l[i] + 1))

l[i] и r[i] можем да намерим по идентични начини. Нека разгледаме l[i]. 

За да го създадем обхождаме arr[i] от началото като всеки елемент добавяме в стек. Всеки следващ 
елемент, който обхождаме премахва от върха на стека по-големите от него стойности. Когато намери 
елемент в стека, който е по-малък от него значи сме стигнали до първият по-малък елемент в масива
отляво. Запазваме индекса на този елемент в l[i] и продължаваме. 
Бележка: Всеки елемент влиза и излиза точно веднъж в стека, та цялата сложност на създаването на 
l[i] е O(n)
*/


long long n, answer = 0, arr[1000000], l[1000000], r[1000000];
stack<long long> s;

int main() {
    cin >> n;
    // Първо намираме l[i] докато въвеждаме arr[i]
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
        // От елементите на s изкарваме по-големите от arr[i]
        while (!s.empty() && arr[s.top()] >= arr[i]) {
            s.pop();
        }
        // Ако сме изкарали всички елементи от s, значи arr[i] e най-малкият срещнат досега елемент
        if (s.empty()) {
            // Тъй като няма елемент по-малък от arr[i] записваме -1 в l[i]
            l[i] = -1;
        } else {
            // В случай, че намерим по-малък елемент то записваме индекса му в в l[i]
            l[i] = s.top();
        }
        s.push(i);
    }

    // Намираме r[i] аналогично на l[i]
    s = stack<long long>();
    for (int i = n - 1; i >= 0; i--) {
        while (!s.empty() && arr[s.top()] >= arr[i]) {
            s.pop();
        }
        if (s.empty()) {
            r[i] += n;
        } else {
            r[i] += s.top();
        }
        s.push(i);
    }
    // Намираме максималното лице от всички лица на правоъгълници където arr[i] е минимален елемнет
    for(int i=0;i<n;++i) {
        answer = max(answer, (r[i] - l[i] -1) * arr[i]);
    }

    cout << answer << endl;
}
