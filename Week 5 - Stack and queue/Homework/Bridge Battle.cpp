#include <cmath>
#include <stack>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

/*
Идеята тук е следната: 
Докато идват бойци с позитивна стойност по моста ги добавяме в стек. 
В моментът, в който видим боец, с отрицателна стойност, той трябва да 
победи всички бойци с поситивна стойност, които са на моста. Това трябва 
да стане точно в реда, в който те ще излязат от стека. 
За всеки боец на върха на стека сравняваме неговата сила, с тази на 
боецът с отрицателна стойност и го премахваме ако е по-слаб. Това 
го повтаряме, докато стекът не се изпразни или не се намери по-силен 
боец от нововъведения. 
Ако срещнем пък някой с равна сила изкарваме го от стека и приключваме.
Ако накрая стекът е празен, то боецът с отрицателна стойност е преминал
успешно моста и можем да го изведем. 
Накрая след като сме въвели всички стойонсти има шанс на моста да са 
останали бойци с положителна стойност. Те също могат да преминат, но 
това трябва да стане в ред обратен на реда, в който ще излязат от стека.
Затова използваме втори стек, за да обърнем последователността на елементите
в първия.
*/

int n, arr[1000000];
stack<int> positives;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin>>n;
    for(int i=0;i<n;++i) {
        cin>>arr[i];
        if(arr[i] > 0) {
            // Срещнали сме боец с позитивна стойност и го запазваме в стека
            positives.push(arr[i]);
        } else {
            // Срещнали сме боец с отрицателна стойност
            // Той побеждава всички по-слаби от него бойци
            while(!positives.empty() && (-arr[i]) > positives.top()) {
                positives.pop();
            }
            // Ако срещне някой равносилен и двамата отпадат
            if(!positives.empty() && positives.top() == -arr[i]) {
                positives.pop();
            } else if(positives.empty()) {
                // победил е всички опоненти и може да премине
                cout<<arr[i]<<" ";
            }
        }
    }
    // Останалите бойци изкараме в същия ред, в който са срещнати, което значи, че
    // трябва да е в ред обратен на реда, в който ще излязат от стека. Използваме
    // втори стек, за да reverse-нем първия.
    stack<int> reversePositives;
    while(!positives.empty()) {
        reversePositives.push(positives.top());
        positives.pop();
    }
    while(!reversePositives.empty()) {
        cout<<reversePositives.top()<<" ";
        reversePositives.pop();
    }
}
